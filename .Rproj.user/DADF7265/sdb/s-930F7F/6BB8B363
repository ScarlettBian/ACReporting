{
    "collab_server" : "",
    "contents" : "#' @name Tucker_equating\n#' @title A function to do the Tucker linear equating.\n#' @description It produces ItemStats file (for both old test and new test) and equating table.\n#' Plots of liking item score and total score distribution are also developed.\n#' @param MainPath The folder where the response files are stored in\n#' @param Xpath Path of the old response file is stored in\n#' @param Ypath Path of the new response file is stored in\n#' @param XName Name of the X test (without \"_Listening\" or \"_Reading\")\n#' @param XName Name of the Y test\n#' @param n_demoX Number of demographic variables in X. Default value is 6.\n#' @param n_demoY Number of demographic variables in Y.\n#' @param DNS_X_r Vector of not score items in X reading test. Default is NULL.\n#' @param DNS_X_l Vector of not score items in X listening test.\n#' @param DNS_Y_r Vector of not score items in Y reading test.\n#' @param DNS_Y_l Vector of not score items in Y listening test.\n#' @param keychange_X_r List of key change for X reading test. Default is NULL.\n#' The first element is the item index, the rest are the keys.\n#' @param keychange_X_l List of key change for X listening test.\n#' @param keychange_Y_r List of key change for Y reading test.\n#' @param keychange_Y_l List of key change for Y listening test.\n#' @param equate_coef_l List of Tucker linear equating coefficience for Listening.\n#' First element is intercept, second is slope.\n#' e.g. c_2015 equates 2016 test score to 2015. When using this function, just fill in proper equating coefficience.\n#' @param equate_coef_r List of Tucker linear equating coefficience for Reading.\n#' @return Stats for both forms of test and the equating table.\n#' @export\n#' @examples\n#' Tucker_equating(MainPath, XPath, YPath, XName, YName, n_demoX=6, n_demoY=6,\n#'  DNS_X_r=NULL, DNS_X_l=c(1,5), DNS_Y_r=NULL, DNS_Y_l=NULL,\n#'  keychange_X_r=list(c(2,1,4),c(13, 2)), keychange_X_l=NULL, keychange_Y_r=NULL, kechange_Y_l=NULL,\n#'  equate_coef_l=list(c_2015=c(-2.282018,1.052596),\n#'                 c_2014=c(-1.848358,1.014028),\n#'                 c_2013=c(2.308507,0.9523797),\n#'                 c_2012=c(3.089623,0.9053153)),\n#'  equate_coef_r=list(c_2015=c(-2.978765,1.013981),\n#'                 c_2014=c(5.188769,0.8741792),\n#'                 c_2013=c(1.171173,0.9723494),\n#'                 c_2012=c(-3.480369,1.05726)))\n\n\nTucker_equating<-function(MainPath, XPath, YPath, XName, YName, n_demoX=6, n_demoY=6,\n                          DNS_X_r=NULL, DNS_X_l=NULL, DNS_Y_r=NULL, DNS_Y_l=NULL,\n                          keychange_X_r=NULL, keychange_X_l=NULL, keychange_Y_r=NULL, keychange_Y_l=NULL,\n                          equate_coef_l=list(c_2015=c(-2.282018,1.052596),\n                                           c_2014=c(-1.848358,1.014028),\n                                           c_2013=c(2.308507,0.9523797),\n                                           c_2012=c(3.089623,0.9053153)),\n                          equate_coef_r=list(c_2015=c(-2.978765,1.013981),\n                                             c_2014=c(5.188769,0.8741792),\n                                             c_2013=c(1.171173,0.9723494),\n                                             c_2012=c(-3.480369,1.05726)))\n{\n library(equate)\n library(psych)\n for (Skill in c(\"Reading\", \"Listening\"))\n {\n   # create path for equating\n   EquatingPath <- paste0(MainPath,\"/Equating/\")\n   if (file.exists(EquatingPath)==F)\n   {\n     dir.create(file.path(EquatingPath))\n   }\n   #### compute Item Stats ####\n   # Read in response matrices\n   X_Data <- ReadCSVFile(XPath, paste0(XName, \"_\", Skill))\n   Y_Data <- ReadCSVFile(YPath, paste0(YName, \"_\", Skill))\n\n   # Ommited response\n   X_Responses<-X_Data[,-(1:n_demoX)]\n   X_Responses<-replace(X_Responses, X_Responses==-1, 8)\n   X_Responses<-replace(X_Responses, X_Responses==\"NA\", 8)\n   X_Responses<-replace(X_Responses, is.na(X_Responses), 8)\n   Y_Responses<-Y_Data[,-(1:n_demoY)]\n   Y_Responses<-replace(Y_Responses, Y_Responses==-1, 8)\n   Y_Responses<-replace(Y_Responses, Y_Responses==\"NA\", 8)\n   Y_Responses<-replace(Y_Responses, is.na(Y_Responses), 8)\n\n   # keychange\n   if (Skill==\"Reading\")\n   {\n     keychange_X<-keychange_X_r\n   } else keychange_X<-keychange_X_l\n\n   if (length(keychange_X)!=0)\n   {\n     for (k in 1:length(keychange_X))\n     {\n       ind<-which(X_Responses[,keychange_X[[k]][1]] %in% keychange_X[[k]][-1])\n       X_Responses[ind,keychange_X[[k]][1]]<-1\n       X_Responses[-ind,keychange_X[[k]][1]]<-0\n     }\n   }\n\n   if (Skill==\"Reading\")\n   {\n     keychange_Y<-keychange_Y_r\n   } else keychange_Y<-keychange_Y_l\n\n   if (length(keychange_Y)!=0)\n   {\n     for (k in 1:length(keychange_Y))\n     {\n       ind<-which(Y_Responses[,keychange_Y[[k]][1]] %in% keychange_Y[[k]][-1])\n       Y_Responses[ind,keychange_Y[[k]][1]]<-1\n       Y_Responses[-ind,keychange_Y[[k]][1]]<-0\n     }\n   }\n\n   # DNS\n   # Build matrix of attempted responses and scored responses for Form X\n   if(Skill==\"Reading\")\n   {\n     DNS_X<-DNS_X_r\n   } else DNS_X<-DNS_X_l\n\n   X_Responses[,DNS_X]<- -1\n   ind_DNS<-which(X_Responses==-1)\n   if (length(ind_DNS)<1) ind_DNS=NULL\n   ind_missing<-which(X_Responses==8)\n   if (length(ind_missing)<1) ind_missing=NULL\n\n   ind_wrong<-which(X_Responses!=1)\n\n   X_ItemAttempts<-as.matrix(X_Responses)\n   X_ItemAttempts[c(ind_DNS,ind_missing)]<- 0\n   X_ItemAttempts[ind_wrong]<- 1\n\n   X_ItemScores<-X_ItemAttempts\n   X_ItemScores[ind_wrong]<-0\n\n   N_x      <- nrow(X_Responses) # sample size\n   Nitems_x <- ncol(X_Responses) # test length\n\n   # Compute Percent \"Attempted\" Vector for Items in Form X\n   X_UnitVec <- rep(1, N_x)\n   X_Prop_Attempted <- (1/N_x)*(X_UnitVec %*% X_ItemAttempts) # 0 for DNS\n\n   # Compute Percent Correct (Item Difficulty) for Form X\n   X_Prop_Correct <- (1/N_x)*(X_UnitVec %*% X_ItemScores)   # 0 for DNS\n\n   # Build matrix of attempted responses and scored responses for Form Y\n   if(Skill==\"Reading\")\n   {\n     DNS_Y<-DNS_Y_r\n   } else DNS_Y<-DNS_Y_l\n\n   Y_Responses[,DNS_Y]<- -1\n   ind_DNS<-which(Y_Responses==-1)\n   if (length(ind_DNS)<1) ind_DNS=NULL\n   ind_missing<-which(Y_Responses==8)\n   if (length(ind_missing)<1) ind_missing=NULL\n\n   ind_wrong<-which(Y_Responses!=1)\n\n   Y_ItemAttempts<-as.matrix(Y_Responses)\n   Y_ItemAttempts[c(ind_DNS,ind_missing)]<- 0\n   Y_ItemAttempts[ind_wrong]<- 1\n\n   Y_ItemScores<-Y_ItemAttempts\n   Y_ItemScores[ind_wrong]<-0\n\n   N_y      <- nrow(Y_Responses) # sample size\n   Nitems_y <- ncol(Y_Responses) # test length\n\n   # Compute Percent \"Attempted\" Vector for Items in Form Y\n   Y_UnitVec <- rep(1, N_y)\n   Y_Prop_Attempted <- (1/N_y)*(Y_UnitVec %*% Y_ItemAttempts) # 0 entries for DNS\n\n   # Compute Percent Correct (Item Difficulty) for Form Y\n   Y_Prop_Correct <- (1/N_y)*(Y_UnitVec %*% Y_ItemScores)   # 0 for DNS\n\n   #### Linking Item ID ####\n   if (length(DNS_X)!=0)\n   {\n     ItemID_X<-as.numeric(colnames(X_Responses))[-DNS_X]\n   } else ItemID_X<-as.numeric(colnames(X_Responses))\n\n   if (length(DNS_Y)!=0)\n   {\n     ItemID_Y<-as.numeric(colnames(Y_Responses))[-DNS_Y]\n   } else ItemID_Y<-as.numeric(colnames(Y_Responses))\n\n   LinkingItemIDs<-NULL\n   for (i in 1:length(ItemID_Y))\n   {\n     try1<-ItemID_Y[i]\n     LinkingItemIDs<-c(LinkingItemIDs,ItemID_X[which(ItemID_X==try1)])\n   }\n   NumLinkingItems<- length(LinkingItemIDs)\n\n   # Construct LInking Items Design Map for Form X\n   X_LinkingDesign <- cbind(rep(1,Nitems_x), rep(0,Nitems_x)) # Initialized to [1|0] matrix\n   for (j in 1:Nitems_x)\n   {\n     if (ItemID_X[j] %in% LinkingItemIDs)\n     {\n       X_LinkingDesign[j,2] <- 1    # Turn on the common items\n     }\n   }\n\n   Scores_X_XV <- X_ItemScores %*% X_LinkingDesign # Calculate Total Score in V1\n   # and Common Item Score in V2\n\n   # Calculate Point-biserial and Biserial Correlations for Form X\n   X_Pearson  <- X_Biserial <-rep(0, Nitems_x) # point-biserial & biserial\n\n   for (j in 1:Nitems_x)\n   {\n     if ( X_Prop_Attempted[j] > 0)\n     {   # Calculations only for items not turned off and responded to\n       if (sum(X_ItemScores[,j])==N_x | sum(X_ItemScores[,j])==0)\n       {\n         X_Pearson[j]<-X_Biserial[j]<-0\n       } else {\n         X_Pearson[j]<-cor(Scores_X_XV[,1]-X_ItemScores[, j],X_ItemScores[, j])\n         X_Biserial[j]<-biserial(Scores_X_XV[,1]-X_ItemScores[, j],X_ItemScores[, j])\n       }\n     }\n   }\n\n   # Assemble Table of Descriptive ItemStatistics, Form X\n   dim(X_Prop_Attempted)   <- c(Nitems_x, 1)  # Transpose results vector\n   dim(X_Prop_Correct)     <- c(Nitems_x, 1)  # ditto\n   dim(X_Pearson)          <- c(Nitems_x, 1)  # ditto\n   dim(X_Biserial)         <- c(Nitems_x, 1)  # ditto\n\n   X_DescriptiveStatsTable <- cbind(as.numeric(colnames(X_Responses)), X_LinkingDesign[,2], X_Prop_Attempted, X_Prop_Correct,\n                                    X_Pearson, X_Biserial)\n   DescriptiveStatsColNames <- c(\"Item ID.\", \"Linking\", \"Attempted\", \"Correct\", \"R_pbis\", \"R_bis\")\n   colnames(X_DescriptiveStatsTable) <- DescriptiveStatsColNames\n\n   X_StatsTablefile <- paste0(EquatingPath,Skill, \"_X_ItemStats.csv\")\n   write.csv(X_DescriptiveStatsTable, X_StatsTablefile, row.names=FALSE)\n\n\n   # Construct LInking Items Design Map for Form Y\n   Y_LinkingDesign <- cbind(rep(1,Nitems_y), rep(0,Nitems_y)) # Initialized to [1|0] matrix\n   for (j in 1:Nitems_y)\n   {\n     if (ItemID_Y[j] %in% LinkingItemIDs)\n     {\n       Y_LinkingDesign[j,2] <- 1    # Turn on the common items\n     }\n   }\n\n   Scores_Y_YV <- Y_ItemScores %*% Y_LinkingDesign # Calculate Total Score in V1\n   # and Common Item Score in V2\n\n   # Calculate Point-biserial and Biserial Correlations for Form Y\n   Y_Pearson  <- Y_Biserial <-rep(0, Nitems_y) # point-biserial & biserial\n\n   for (j in 1:Nitems_y)\n   {\n     if ( Y_Prop_Attempted[j] > 0)\n     {   # Calculations only for items not turned off and responded to\n       if (sum(Y_ItemScores[,j])==N_y | sum(Y_ItemScores[,j])==0)\n       {\n         Y_Pearson[j]<-Y_Biserial[j]<-0\n       } else {\n         Y_Pearson[j]<-cor(Scores_Y_YV[,1]-Y_ItemScores[, j],Y_ItemScores[, j])\n         Y_Biserial[j]<-biserial(Scores_Y_YV[,1]-Y_ItemScores[, j],Y_ItemScores[, j])\n       }\n     }\n   }\n\n   # Assemble Table of Descriptive ItemStatistics, Form Y\n   dim(Y_Prop_Attempted)   <- c(Nitems_y, 1)  # Transpose results vector\n   dim(Y_Prop_Correct)     <- c(Nitems_y, 1)  # ditto\n   dim(Y_Pearson)          <- c(Nitems_y, 1)  # ditto\n   dim(Y_Biserial)         <- c(Nitems_y, 1)  # ditto\n\n   Y_DescriptiveStatsTable <- cbind(as.numeric(colnames(Y_Responses)), Y_LinkingDesign[,2], Y_Prop_Attempted, Y_Prop_Correct,\n                                    Y_Pearson, Y_Biserial)\n   colnames(Y_DescriptiveStatsTable) <- DescriptiveStatsColNames\n\n   Y_StatsTablefile <- paste0(EquatingPath,Skill, \"_Y_ItemStats.csv\")\n   write.csv(Y_DescriptiveStatsTable, Y_StatsTablefile, row.names=FALSE)\n\n   #### Equating ####\n   # Freqs of X and V, Pop 1\n   neat.x <- freqtab(Scores_X_XV, scales=list(0:Nitems_x,0:NumLinkingItems) )\n   # Freqs of y and V, Pop 2\n   neat.y <- freqtab(Scores_Y_YV, scales=list(0:Nitems_y,0:NumLinkingItems) )\n\n   jpeg(paste0(EquatingPath,Skill, \"_neat_X.jpg\"))\n   plot(neat.x, xlab=\"Total Test\", ylab=\"Anchor Test\")  # Plot of V against X in Population 1\n   dev.off()\n   jpeg(paste0(EquatingPath,Skill, \"_neat_Y.jpg\"))\n   plot(neat.y, xlab=\"Total Test\", ylab=\"Anchor Test\")  # Plot of V against Y in Population 2\n   dev.off()\n\n   # Tucker Raw Score Equating\n   neat.Tucker <- equate(neat.y, neat.x, type='linear', method = 'tucker')\n\n   # Equating Constants\n\n   cat(\"\\nMapping Y to X by Tucker Equating:\\n\")\n\n   Tucker_slope <- neat.Tucker$coeff[[2]] # Reciprocal of Albano's Slope\n   Tucker_icpt  <- neat.Tucker$coeff[[1]]\n\n   cat(\"Intercept: \", Tucker_icpt,\"\\n\")\n   cat(\"    Slope: \", Tucker_slope,\"\\n\")\n\n   # Equating table\n   if (Skill==\"Listening\")\n   {\n     equate_coef<-equate_coef_l\n   } else {\n     equate_coef<-equate_coef_r\n   }\n   equating_table<-matrix(, ncol=3+length(equate_coef), nrow=Nitems_y-length(DNS_Y)+1)\n   equating_table[,1]<-seq(from = 0, to = Nitems_y-length(DNS_Y), by = 1) # Form Y score\n   equating_table[,2]<-Tucker_icpt + Tucker_slope*equating_table[,1] # Form X score\n   for (k in 1:length(equate_coef))\n   {\n     equating_table[,2+k]<-equate_coef[[k]][1] + equate_coef[[k]][2]*equating_table[,1+k]\n   }\n   equating_table[,3+length(equate_coef)]<- round(equating_table[,2+length(equate_coef)])\n   equating_table[,3+length(equate_coef)] <- equating_table[,3+length(equate_coef)] * (equating_table[,3+length(equate_coef)] >= 0.0)\n\n   table_head_sub<-NULL\n   name_sub<-\"2012\"\n   for (k in 1:(1+length(equate_coef)))\n   {\n     table_head_sub[k]<-paste0(\"Tucker_Equated_\", 2011+k, \"_Float\")\n     name_sub<-paste(2012+k,name_sub, sep=\"_\")\n   }\n   table_head<-c(\"Form_Y_Score\", table_head_sub[(1+length(equate_coef)):1], \"Tucker_Equated_2012_Score\")\n   colnames(equating_table)<-table_head\n\n   write.csv(equating_table,file=paste0(EquatingPath, \"Tucker\", name_sub,\"_\",Skill, \"EquatingTable.csv\"), row.names=FALSE)\n }\n}\n",
    "created" : 1501261409145.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1451840154",
    "id" : "6BB8B363",
    "lastKnownWriteTime" : 1501261211,
    "last_content_update" : 1501261211,
    "path" : "~/Google Drive/AC/ACReporting/R/equating_function.R",
    "project_path" : "R/equating_function.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}